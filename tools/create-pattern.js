#!/usr/bin/env bun

/**
 * Pattern Template Generator for KRINS-Chronicle-Keeper
 * Creates new patterns based on established templates with automatic ADR creation
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class PatternGenerator {
  constructor() {
    this.rootDir = process.cwd();
    this.patternsDir = path.join(this.rootDir, 'docs', 'patterns');
    this.adrDir = path.join(this.rootDir, 'docs', 'adr');
  }

  log(level, message) {
    const prefix = {
      'error': 'âŒ',
      'warn': 'âš ï¸ ',
      'info': 'âœ…',
      'success': 'ðŸŽ‰',
      'debug': 'ðŸ”'
    }[level] || 'ðŸ“‹';
    
    console.log(`${prefix} ${message}`);
  }

  async generatePattern(patternName, category, description, codeExample = '', relatedTechnologies = []) {
    try {
      this.log('info', `Creating new pattern: ${patternName}`);
      
      // Ensure patterns directory exists
      const categoryDir = path.join(this.patternsDir, category);
      if (!fs.existsSync(categoryDir)) {
        fs.mkdirSync(categoryDir, { recursive: true });
        this.log('info', `Created category directory: ${category}`);
      }
      
      // Generate pattern file
      const patternFile = path.join(categoryDir, `${patternName.toLowerCase().replace(/\s+/g, '-')}-pattern.md`);
      const patternContent = this.generatePatternContent(patternName, category, description, codeExample, relatedTechnologies);
      
      fs.writeFileSync(patternFile, patternContent);
      this.log('success', `Pattern created: ${patternFile}`);
      
      // Create related ADR if requested
      if (process.argv.includes('--create-adr')) {
        this.createRelatedADR(patternName, category, description);
      }
      
      // Update patterns index
      this.updatePatternsIndex(patternName, category);
      
      return patternFile;
    } catch (error) {
      this.log('error', `Failed to create pattern: ${error.message}`);
      throw error;
    }
  }
  
  generatePatternContent(name, category, description, codeExample, technologies) {
    const now = new Date().toISOString().split('T')[0];
    
    return `# ${name}

## Description
${description}

## Category
${category}

## Usage
This pattern is applicable when:
- [Describe when to use this pattern]
- [List specific use cases]
- [Mention benefits and trade-offs]

## Implementation

### Code Example
\`\`\`${this.detectLanguage(codeExample)}
${codeExample || '// Add your code example here'}
\`\`\`

### Prerequisites
- ${technologies.length > 0 ? technologies.join('\n- ') : '[List required technologies or dependencies]'}

## Related Technologies
${technologies.length > 0 ? technologies.map(tech => `- ${tech}`).join('\n') : '- [Add related technologies]'}

## Benefits
- [List key benefits of using this pattern]
- [Mention performance improvements]
- [Note maintainability advantages]

## Trade-offs
- [Describe potential drawbacks]
- [Mention complexity considerations]
- [Note resource requirements]

## Examples
### Basic Usage
\`\`\`${this.detectLanguage(codeExample)}
// Basic implementation example
\`\`\`

### Advanced Usage
\`\`\`${this.detectLanguage(codeExample)}
// Advanced implementation with edge cases
\`\`\`

## Testing Strategy
- [Describe how to test implementations of this pattern]
- [List key test scenarios]
- [Mention performance benchmarks]

## Related Patterns
- [Link to related patterns]
- [Mention alternative approaches]

## Related ADRs
- [List relevant Architecture Decision Records]

## Changelog
- ${now}: Pattern created

---
*Generated by KRINS-Chronicle-Keeper Pattern Generator*`;
  }
  
  detectLanguage(code) {
    if (code.includes('import ') || code.includes('export ') || code.includes(': string')) return 'typescript';
    if (code.includes('def ') || code.includes('import ')) return 'python';
    if (code.includes('public class') || code.includes('@Override')) return 'java';
    if (code.includes('function') || code.includes('const ')) return 'javascript';
    return 'text';
  }
  
  createRelatedADR(patternName, category, description) {
    try {
      const adrTitle = `Implement ${patternName} Pattern`;
      const adrComponent = `patterns/${category}`;
      
      // Use existing adr_new.sh script
      execSync(`./tools/adr_new.sh "${adrTitle}" "${adrComponent}"`, { cwd: this.rootDir });
      this.log('success', `Created related ADR for ${patternName}`);
    } catch (error) {
      this.log('warn', `Could not create ADR: ${error.message}`);
    }
  }
  
  updatePatternsIndex(patternName, category) {
    const indexFile = path.join(this.patternsDir, 'README.md');
    
    if (!fs.existsSync(indexFile)) {
      const indexContent = `# Pattern Library Index

## Categories

### ${category}
- [${patternName}](./${category}/${patternName.toLowerCase().replace(/\s+/g, '-')}-pattern.md)

---
*Automatically updated by Pattern Generator*`;
      
      fs.writeFileSync(indexFile, indexContent);
    } else {
      // Update existing index (simple append for now)
      let content = fs.readFileSync(indexFile, 'utf8');
      const patternLink = `- [${patternName}](./${category}/${patternName.toLowerCase().replace(/\s+/g, '-')}-pattern.md)`;
      
      if (!content.includes(patternLink)) {
        if (content.includes(`### ${category}`)) {
          // Add to existing category
          content = content.replace(`### ${category}`, `### ${category}\n${patternLink}`);
        } else {
          // Add new category
          content = content.replace('---', `\n### ${category}\n${patternLink}\n\n---`);
        }
        fs.writeFileSync(indexFile, content);
      }
    }
    
    this.log('info', 'Updated patterns index');
  }
  
  listPatterns() {
    this.log('info', 'Available patterns:');
    
    if (!fs.existsSync(this.patternsDir)) {
      this.log('warn', 'No patterns directory found');
      return;
    }
    
    const categories = fs.readdirSync(this.patternsDir, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => dirent.name);
    
    categories.forEach(category => {
      this.log('info', `\nðŸ“ ${category.toUpperCase()}`);
      const categoryPath = path.join(this.patternsDir, category);
      const patterns = fs.readdirSync(categoryPath)
        .filter(file => file.endsWith('-pattern.md'))
        .map(file => file.replace('-pattern.md', '').replace(/-/g, ' '));
      
      patterns.forEach(pattern => {
        this.log('debug', `  - ${pattern}`);
      });
    });
  }
}

// CLI Interface
async function main() {
  const generator = new PatternGenerator();
  const args = process.argv.slice(2);
  
  if (args.length === 0 || args.includes('--help')) {
    console.log(`
ðŸŽ¨ KRINS-Chronicle-Keeper Pattern Generator

Usage:
  node create-pattern.js <name> <category> <description> [options]
  node create-pattern.js --list
  
Options:
  --create-adr     Also create a related ADR
  --code <file>    Include code example from file
  --tech <list>    Comma-separated list of technologies
  
Examples:
  node create-pattern.js "API Response" typescript "Standardized API response format"
  node create-pattern.js "Database Service" backend "Database connection pattern" --create-adr
  node create-pattern.js --list
`);
    return;
  }
  
  if (args[0] === '--list') {
    generator.listPatterns();
    return;
  }
  
  if (args.length < 3) {
    generator.log('error', 'Missing required arguments: name, category, description');
    process.exit(1);
  }
  
  const [name, category, description] = args;
  let codeExample = '';
  let technologies = [];
  
  // Parse additional options
  const codeIndex = args.indexOf('--code');
  if (codeIndex !== -1 && args[codeIndex + 1]) {
    const codeFile = args[codeIndex + 1];
    if (fs.existsSync(codeFile)) {
      codeExample = fs.readFileSync(codeFile, 'utf8');
    }
  }
  
  const techIndex = args.indexOf('--tech');
  if (techIndex !== -1 && args[techIndex + 1]) {
    technologies = args[techIndex + 1].split(',').map(t => t.trim());
  }
  
  try {
    await generator.generatePattern(name, category, description, codeExample, technologies);
    generator.log('success', 'Pattern generation complete!');
  } catch (error) {
    generator.log('error', 'Pattern generation failed');
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = PatternGenerator;