/**
 * ðŸ“‹ KRINS ADR Generator
 * Revolutionary system that automatically generates Architecture Decision Records from GitHub events
 */

import { v4 as uuidv4 } from 'uuid';
import { createLogger, format, transports } from 'winston';
import fs from 'fs/promises';
import path from 'path';

export class ADRGenerator {
  constructor(config = {}) {
    this.config = {
      adrDirectory: config.adrDirectory || './docs/adr',
      templatePath: config.templatePath || './docs/adr/templates',
      autoGenerateThreshold: config.autoGenerateThreshold || 'medium',
      maxADRsPerDay: config.maxADRsPerDay || 5,
      ...config
    };

    // ADR generation statistics
    this.stats = {
      adrsGenerated: 0,
      autoGeneratedToday: 0,
      lastGenerationDate: null,
      averageGenerationTime: 0,
      successfulGenerations: 0,
      failedGenerations: 0
    };

    // Decision categories for classification
    this.decisionCategories = {
      'architectural': ['architecture', 'design', 'pattern', 'structure'],
      'technical': ['technology', 'framework', 'library', 'tool'],
      'security': ['security', 'authentication', 'authorization', 'vulnerability'],
      'performance': ['performance', 'optimization', 'scalability', 'caching'],
      'integration': ['api', 'integration', 'service', 'database'],
      'infrastructure': ['deployment', 'infrastructure', 'devops', 'monitoring'],
      'process': ['workflow', 'process', 'methodology', 'practices']
    };

    this.logger = createLogger({
      level: 'info',
      format: format.combine(
        format.timestamp(),
        format.printf(({ timestamp, level, message, ...meta }) => {
          return `${timestamp} [ADRGenerator] [${level}] ${message} ${Object.keys(meta).length ? JSON.stringify(meta) : ''}`;
        })
      ),
      transports: [
        new transports.Console({ level: 'info' })
      ]
    });
  }

  /**
   * Analyze GitHub event and determine if ADR generation is needed
   */
  async analyzeEvent(eventType, payload) {
    try {
      this.logger.info('Analyzing GitHub event for ADR generation', {
        event_type: eventType
      });

      const analysis = {
        shouldGenerateADR: false,
        confidence: 0,
        category: null,
        title: null,
        context: null,
        reasoning: []
      };

      switch (eventType) {
        case 'pull_request':
          return await this.analyzePullRequest(payload, analysis);
        
        case 'push':
          return await this.analyzePush(payload, analysis);
        
        case 'issues':
          return await this.analyzeIssue(payload, analysis);
        
        case 'release':
          return await this.analyzeRelease(payload, analysis);
        
        default:
          this.logger.debug('Event type not suitable for ADR generation', { event_type: eventType });
          return analysis;
      }

    } catch (error) {
      this.logger.error('Failed to analyze event for ADR generation', {
        event_type: eventType,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Analyze pull request for ADR potential
   */
  async analyzePullRequest(payload, analysis) {
    const pr = payload.pull_request;
    if (!pr) return analysis;

    const title = pr.title?.toLowerCase() || '';
    const body = pr.body?.toLowerCase() || '';
    const files = payload.files || [];

    // Check for architectural significance
    const architecturalKeywords = [
      'architecture', 'design', 'pattern', 'framework', 'breaking change',
      'major refactor', 'migration', 'new service', 'deprecate', 'replace'
    ];

    const hasArchitecturalKeywords = architecturalKeywords.some(keyword => 
      title.includes(keyword) || body.includes(keyword)
    );

    // Check file changes
    const significantFiles = files.filter(file => 
      file.filename.includes('package.json') ||
      file.filename.includes('config') ||
      file.filename.includes('schema') ||
      file.filename.includes('migration') ||
      file.status === 'removed'
    );

    // Calculate confidence
    let confidence = 0;
    const reasoning = [];

    if (hasArchitecturalKeywords) {
      confidence += 40;
      reasoning.push('Contains architectural keywords');
    }

    if (significantFiles.length > 0) {
      confidence += 30;
      reasoning.push(`Modified ${significantFiles.length} significant files`);
    }

    if (pr.changed_files > 20) {
      confidence += 20;
      reasoning.push('Large change set');
    }

    if (pr.additions + pr.deletions > 500) {
      confidence += 10;
      reasoning.push('Substantial code changes');
    }

    // Determine category and title
    const category = this.categorizeDecision(title + ' ' + body);
    
    if (confidence >= 60) {
      analysis.shouldGenerateADR = true;
      analysis.confidence = confidence;
      analysis.category = category;
      analysis.title = this.generateTitle(pr.title, category);
      analysis.context = {
        pr_number: pr.number,
        pr_url: pr.html_url,
        author: pr.user?.login,
        changes: {
          files: pr.changed_files,
          additions: pr.additions,
          deletions: pr.deletions
        },
        description: pr.body
      };
      analysis.reasoning = reasoning;
    }

    return analysis;
  }

  /**
   * Analyze push events for ADR potential
   */
  async analyzePush(payload, analysis) {
    const commits = payload.commits || [];
    if (commits.length === 0) return analysis;

    // Look for significant commits
    const significantCommits = commits.filter(commit => {
      const message = commit.message.toLowerCase();
      return message.includes('breaking') ||
             message.includes('major') ||
             message.includes('architecture') ||
             message.includes('migration') ||
             message.includes('deprecate');
    });

    if (significantCommits.length > 0) {
      const mainCommit = significantCommits[0];
      const category = this.categorizeDecision(mainCommit.message);

      analysis.shouldGenerateADR = true;
      analysis.confidence = 70;
      analysis.category = category;
      analysis.title = this.generateTitle(mainCommit.message, category);
      analysis.context = {
        commits: significantCommits.length,
        main_commit: {
          sha: mainCommit.id,
          message: mainCommit.message,
          author: mainCommit.author?.name,
          url: mainCommit.url
        },
        repository: payload.repository?.full_name
      };
      analysis.reasoning = ['Significant commits detected'];
    }

    return analysis;
  }

  /**
   * Analyze issues for ADR potential
   */
  async analyzeIssue(payload, analysis) {
    if (payload.action !== 'opened') return analysis;

    const issue = payload.issue;
    const title = issue.title?.toLowerCase() || '';
    const body = issue.body?.toLowerCase() || '';
    const labels = issue.labels?.map(label => label.name.toLowerCase()) || [];

    // Check for decision-related labels
    const decisionLabels = ['decision', 'architecture', 'design', 'technical-decision'];
    const hasDecisionLabel = labels.some(label => 
      decisionLabels.some(dl => label.includes(dl))
    );

    // Check for architectural significance in content
    const architecturalKeywords = [
      'should we use', 'decision needed', 'architecture review',
      'technical approach', 'design decision', 'technology choice'
    ];

    const hasArchitecturalContent = architecturalKeywords.some(keyword => 
      title.includes(keyword) || body.includes(keyword)
    );

    if (hasDecisionLabel || hasArchitecturalContent) {
      const category = this.categorizeDecision(title + ' ' + body);

      analysis.shouldGenerateADR = true;
      analysis.confidence = hasDecisionLabel ? 80 : 60;
      analysis.category = category;
      analysis.title = this.generateTitle(issue.title, category);
      analysis.context = {
        issue_number: issue.number,
        issue_url: issue.html_url,
        author: issue.user?.login,
        labels: labels,
        description: issue.body
      };
      analysis.reasoning = hasDecisionLabel ? 
        ['Issue has decision-related label'] : 
        ['Issue content suggests architectural decision'];
    }

    return analysis;
  }

  /**
   * Analyze releases for ADR potential
   */
  async analyzeRelease(payload, analysis) {
    const release = payload.release;
    if (!release) return analysis;

    // Major releases often involve architectural decisions
    const isMajorRelease = release.tag_name.includes('v1.') ||
                          release.tag_name.includes('v2.') ||
                          release.tag_name.includes('v3.') ||
                          release.name?.toLowerCase().includes('major');

    if (isMajorRelease) {
      analysis.shouldGenerateADR = true;
      analysis.confidence = 75;
      analysis.category = 'architectural';
      analysis.title = `Architecture Decisions for ${release.name || release.tag_name}`;
      analysis.context = {
        release_tag: release.tag_name,
        release_name: release.name,
        release_url: release.html_url,
        author: release.author?.login,
        description: release.body
      };
      analysis.reasoning = ['Major release detected'];
    }

    return analysis;
  }

  /**
   * Categorize decision based on content
   */
  categorizeDecision(content) {
    const lowerContent = content.toLowerCase();
    
    for (const [category, keywords] of Object.entries(this.decisionCategories)) {
      if (keywords.some(keyword => lowerContent.includes(keyword))) {
        return category;
      }
    }

    return 'technical'; // default category
  }

  /**
   * Generate ADR title based on source and category
   */
  generateTitle(sourceTitle, category) {
    // Clean up the source title
    let cleanTitle = sourceTitle
      .replace(/^(feat|fix|docs|style|refactor|test|chore):\s*/i, '')
      .replace(/^(add|remove|update|implement|create):\s*/i, '')
      .trim();

    // Capitalize first letter
    cleanTitle = cleanTitle.charAt(0).toUpperCase() + cleanTitle.slice(1);

    // Add category context if not already present
    const categoryPrefixes = {
      'architectural': 'Architecture:',
      'technical': 'Technology:',
      'security': 'Security:',
      'performance': 'Performance:',
      'integration': 'Integration:',
      'infrastructure': 'Infrastructure:',
      'process': 'Process:'
    };

    const prefix = categoryPrefixes[category];
    if (prefix && !cleanTitle.toLowerCase().includes(category)) {
      return `${prefix} ${cleanTitle}`;
    }

    return cleanTitle;
  }

  /**
   * Generate ADR from analysis
   */
  async generateADR(analysis, additionalContext = {}) {
    if (!analysis.shouldGenerateADR) {
      throw new Error('Analysis does not support ADR generation');
    }

    const startTime = Date.now();

    try {
      // Check daily limit
      const today = new Date().toDateString();
      if (this.stats.lastGenerationDate !== today) {
        this.stats.autoGeneratedToday = 0;
        this.stats.lastGenerationDate = today;
      }

      if (this.stats.autoGeneratedToday >= this.config.maxADRsPerDay) {
        throw new Error(`Daily ADR generation limit reached (${this.config.maxADRsPerDay})`);
      }

      // Get next ADR number
      const adrNumber = await this.getNextADRNumber();
      
      // Generate ADR content
      const adrContent = await this.generateADRContent(adrNumber, analysis, additionalContext);
      
      // Write ADR file
      const filename = `ADR-${adrNumber.toString().padStart(4, '0')}-${this.slugify(analysis.title)}.md`;
      const filepath = path.join(this.config.adrDirectory, filename);
      
      await fs.writeFile(filepath, adrContent, 'utf8');

      // Update statistics
      const generationTime = Date.now() - startTime;
      this.updateStats(true, generationTime);

      this.logger.info('ADR generated successfully', {
        adr_number: adrNumber,
        filename,
        title: analysis.title,
        category: analysis.category,
        generation_time: `${generationTime}ms`
      });

      return {
        success: true,
        adr_number: adrNumber,
        filename,
        filepath,
        title: analysis.title,
        category: analysis.category,
        generation_time: generationTime
      };

    } catch (error) {
      const generationTime = Date.now() - startTime;
      this.updateStats(false, generationTime);
      
      this.logger.error('Failed to generate ADR', {
        title: analysis.title,
        error: error.message,
        generation_time: `${generationTime}ms`
      });
      
      throw error;
    }
  }

  /**
   * Get the next ADR number
   */
  async getNextADRNumber() {
    try {
      const files = await fs.readdir(this.config.adrDirectory);
      const adrFiles = files.filter(file => file.match(/^ADR-\d{4}-.*\.md$/));
      
      if (adrFiles.length === 0) {
        return 1;
      }

      // Extract numbers and find the highest
      const numbers = adrFiles.map(file => {
        const match = file.match(/^ADR-(\d{4})-/);
        return match ? parseInt(match[1], 10) : 0;
      });

      return Math.max(...numbers) + 1;

    } catch (error) {
      this.logger.warn('Could not read ADR directory, starting from 1', {
        directory: this.config.adrDirectory,
        error: error.message
      });
      return 1;
    }
  }

  /**
   * Generate ADR content using template
   */
  async generateADRContent(adrNumber, analysis, additionalContext) {
    const template = await this.loadTemplate(analysis.category);
    
    const variables = {
      ADR_NUMBER: adrNumber.toString().padStart(4, '0'),
      TITLE: analysis.title,
      DATE: new Date().toISOString().split('T')[0],
      STATUS: 'Proposed',
      CATEGORY: analysis.category,
      CONTEXT: this.formatContext(analysis.context, additionalContext),
      REASONING: analysis.reasoning.join('\n- '),
      DECISION: this.generateDecisionSection(analysis),
      CONSEQUENCES: this.generateConsequencesSection(analysis),
      ALTERNATIVES: this.generateAlternativesSection(analysis),
      REFERENCES: this.generateReferencesSection(analysis.context)
    };

    let content = template;
    for (const [key, value] of Object.entries(variables)) {
      content = content.replace(new RegExp(`{{${key}}}`, 'g'), value || '');
    }

    return content;
  }

  /**
   * Load ADR template for category
   */
  async loadTemplate(category) {
    const templateFiles = [
      `${category}-adr-template.md`,
      'default-adr-template.md'
    ];

    for (const templateFile of templateFiles) {
      try {
        const templatePath = path.join(this.config.templatePath, templateFile);
        const content = await fs.readFile(templatePath, 'utf8');
        return content;
      } catch (error) {
        continue; // Try next template
      }
    }

    // Fallback to built-in template
    return this.getBuiltInTemplate();
  }

  /**
   * Built-in ADR template fallback
   */
  getBuiltInTemplate() {
    return `# ADR-{{ADR_NUMBER}}: {{TITLE}}

**Date:** {{DATE}}
**Status:** {{STATUS}}
**Category:** {{CATEGORY}}

## Context

{{CONTEXT}}

## Decision

{{DECISION}}

## Reasoning

- {{REASONING}}

## Consequences

{{CONSEQUENCES}}

## Alternatives Considered

{{ALTERNATIVES}}

## References

{{REFERENCES}}

---

*This ADR was automatically generated based on GitHub activity.*
`;
  }

  /**
   * Format context section
   */
  formatContext(context, additionalContext = {}) {
    const sections = [];
    
    if (context.pr_number) {
      sections.push(`**Pull Request:** #${context.pr_number} - ${context.pr_url}`);
      sections.push(`**Author:** ${context.author}`);
      if (context.changes) {
        sections.push(`**Changes:** ${context.changes.files} files, +${context.changes.additions}/-${context.changes.deletions} lines`);
      }
    }

    if (context.issue_number) {
      sections.push(`**Issue:** #${context.issue_number} - ${context.issue_url}`);
      sections.push(`**Author:** ${context.author}`);
      if (context.labels?.length > 0) {
        sections.push(`**Labels:** ${context.labels.join(', ')}`);
      }
    }

    if (context.main_commit) {
      sections.push(`**Commit:** ${context.main_commit.sha.substring(0, 7)}`);
      sections.push(`**Author:** ${context.main_commit.author}`);
      sections.push(`**Message:** ${context.main_commit.message}`);
    }

    if (context.release_tag) {
      sections.push(`**Release:** ${context.release_tag}`);
      sections.push(`**Author:** ${context.author}`);
    }

    if (context.description) {
      sections.push(`\n**Description:**\n${context.description}`);
    }

    // Add additional context
    if (Object.keys(additionalContext).length > 0) {
      sections.push('\n**Additional Context:**');
      for (const [key, value] of Object.entries(additionalContext)) {
        sections.push(`**${key}:** ${value}`);
      }
    }

    return sections.join('\n');
  }

  /**
   * Generate decision section placeholder
   */
  generateDecisionSection(analysis) {
    return `This decision was triggered by ${analysis.context.pr_number ? 'pull request' : analysis.context.issue_number ? 'issue' : analysis.context.main_commit ? 'commit' : 'release'} activity. The specific decision details need to be reviewed and completed by the development team.`;
  }

  /**
   * Generate consequences section placeholder
   */
  generateConsequencesSection(analysis) {
    return 'The consequences of this decision need to be analyzed and documented by the development team.';
  }

  /**
   * Generate alternatives section placeholder
   */
  generateAlternativesSection(analysis) {
    return 'Alternative approaches and their trade-offs need to be documented by the development team.';
  }

  /**
   * Generate references section
   */
  generateReferencesSection(context) {
    const references = [];

    if (context.pr_url) references.push(`- Pull Request: ${context.pr_url}`);
    if (context.issue_url) references.push(`- Issue: ${context.issue_url}`);
    if (context.main_commit?.url) references.push(`- Commit: ${context.main_commit.url}`);
    if (context.release_url) references.push(`- Release: ${context.release_url}`);

    return references.length > 0 ? references.join('\n') : 'No direct references available.';
  }

  /**
   * Create URL-friendly slug from title
   */
  slugify(text) {
    return text
      .toLowerCase()
      .replace(/[^a-z0-9 -]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .trim('-');
  }

  /**
   * Update generation statistics
   */
  updateStats(success, generationTime) {
    this.stats.adrsGenerated++;
    this.stats.autoGeneratedToday++;
    
    if (success) {
      this.stats.successfulGenerations++;
    } else {
      this.stats.failedGenerations++;
    }

    // Update average generation time
    const totalGenerations = this.stats.successfulGenerations + this.stats.failedGenerations;
    this.stats.averageGenerationTime = 
      ((this.stats.averageGenerationTime * (totalGenerations - 1)) + generationTime) / totalGenerations;
  }

  /**
   * Get generation statistics
   */
  getStats() {
    return {
      ...this.stats,
      success_rate: this.stats.adrsGenerated > 0 ? 
        ((this.stats.successfulGenerations / this.stats.adrsGenerated) * 100).toFixed(2) + '%' :
        '0%',
      daily_limit_remaining: this.config.maxADRsPerDay - this.stats.autoGeneratedToday
    };
  }
}