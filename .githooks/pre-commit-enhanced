#!/bin/bash
# üõ°Ô∏è KRINS Enhanced Pre-Commit Hook - Ultimate Repository Protection
# 
# This hook prevents repository rot by blocking commits that would:
# - Add build artifacts
# - Include secrets or credentials
# - Create structural chaos
# - Violate naming conventions

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}üõ°Ô∏è KRINS Enhanced Pre-Commit Protection${NC}"
echo "======================================="

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Files allowed in root directory
ALLOWED_ROOT_FILES=(
    "README.md"
    "CLAUDE.md" 
    ".gitignore"
    "Dockerfile"
    "docker-compose.yml"
    "Makefile"
    "CODEOWNERS"
    ".editorconfig"
    "LICENSE"
    "KRINS-WORKFLOW.md"
)

# Dangerous patterns to block
SECRET_PATTERNS=(
    "password\s*="
    "secret\s*="
    "api[_-]?key\s*="
    "token\s*="
    "auth[_-]?token"
    "private[_-]?key"
    "access[_-]?key"
    "bearer\s+"
    "sk-[a-zA-Z0-9]{32,}"  # OpenAI API keys
    "ghp_[a-zA-Z0-9]{36}"  # GitHub tokens
)

# Build artifact patterns to block
BUILD_PATTERNS=(
    "\.next/"
    "dist/"
    "build/"
    "out/"
    "coverage/"
    "\.nyc_output/"
    "node_modules/"
    "\.cache/"
    "\.tmp/"
    "\.temp/"
    ".*\.dmg$"
    ".*\.zip$"
    ".*\.tar\.gz$"
    ".*\.deb$"
    ".*\.rpm$"
    ".*\.exe$"
    ".*\.msi$"
)

# File size limit (in bytes)
MAX_FILE_SIZE=52428800  # 50MB

ISSUES_FOUND=0

issue() {
    echo -e "${RED}‚ùå BLOCKED: $1${NC}"
    ((ISSUES_FOUND++))
}

warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  WARNING: $1${NC}"
}

success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

info() {
    echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"
}

# 1. CHECK ROOT DIRECTORY FILES
check_root_files() {
    info "Checking root directory organization..."
    
    # Get files being added to root
    STAGED_ROOT_FILES=$(git diff --cached --name-status | grep -E '^[AM].*[^/]+$' | cut -f2 | grep -E '^[^/]+$' || true)
    
    if [ ! -z "$STAGED_ROOT_FILES" ]; then
        FORBIDDEN_FILES=""
        
        while IFS= read -r file; do
            # Skip if file is in allowed list
            allowed=false
            for allowed_file in "${ALLOWED_ROOT_FILES[@]}"; do
                if [ "$file" = "$allowed_file" ]; then
                    allowed=true
                    break
                fi
            done
            
            # Skip if it's a directory
            if [ -d "$file" ]; then
                allowed=true
            fi
            
            if [ "$allowed" = false ]; then
                FORBIDDEN_FILES="$FORBIDDEN_FILES$file\n"
            fi
        done <<< "$STAGED_ROOT_FILES"
        
        if [ ! -z "$FORBIDDEN_FILES" ]; then
            issue "Loose files in root directory:"
            echo -e "$FORBIDDEN_FILES" | sed 's/^/   - /'
            echo ""
            echo "üí° Move them to appropriate directories:"
            echo "   üìÅ Config files ‚Üí config/ or project directories"
            echo "   üîß Scripts ‚Üí tools/"
            echo "   üìö Documentation ‚Üí docs/ or shared/docs/"
            echo "   üèóÔ∏è Code ‚Üí appropriate feature directories"
        fi
    fi
}

# 2. CHECK FOR BUILD ARTIFACTS  
check_build_artifacts() {
    info "Checking for build artifacts..."
    
    STAGED_FILES=$(git diff --cached --name-only || true)
    
    for pattern in "${BUILD_PATTERNS[@]}"; do
        MATCHES=$(echo "$STAGED_FILES" | grep -E "$pattern" || true)
        if [ ! -z "$MATCHES" ]; then
            issue "Build artifacts being committed:"
            echo "$MATCHES" | sed 's/^/   - /'
            echo ""
            echo "üí° Add these patterns to .gitignore:"
            echo "   $pattern"
        fi
    done
}

# 3. CHECK FOR SECRETS
check_secrets() {
    info "Scanning for secrets and credentials..."
    
    STAGED_FILES=$(git diff --cached --name-only | grep -E '\.(js|ts|py|json|yml|yaml|env|sh|md)$' || true)
    
    if [ ! -z "$STAGED_FILES" ]; then
        for file in $STAGED_FILES; do
            # Get the staged content of the file
            STAGED_CONTENT=$(git show ":$file" 2>/dev/null || true)
            
            if [ ! -z "$STAGED_CONTENT" ]; then
                for pattern in "${SECRET_PATTERNS[@]}"; do
                    MATCHES=$(echo "$STAGED_CONTENT" | grep -i -E "$pattern" || true)
                    if [ ! -z "$MATCHES" ]; then
                        issue "Potential secret in $file:"
                        echo "$MATCHES" | head -3 | sed 's/^/   - /'
                    fi
                done
            fi
        done
    fi
    
    # Check for .env files
    ENV_FILES=$(echo "$STAGED_FILES" | grep "\.env" || true)
    if [ ! -z "$ENV_FILES" ]; then
        issue ".env files being committed:"
        echo "$ENV_FILES" | sed 's/^/   - /'
    fi
}

# 4. CHECK FILE SIZES
check_file_sizes() {
    info "Checking file sizes..."
    
    STAGED_FILES=$(git diff --cached --name-only || true)
    
    for file in $STAGED_FILES; do
        if [ -f "$file" ]; then
            SIZE=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
            if [ $SIZE -gt $MAX_FILE_SIZE ]; then
                SIZE_MB=$((SIZE / 1024 / 1024))
                issue "File too large: $file (${SIZE_MB}MB)"
            fi
        fi
    done
}

# 5. CHECK NAMING CONVENTIONS
check_naming() {
    info "Checking naming conventions..."
    
    STAGED_FILES=$(git diff --cached --name-only || true)
    
    # Check for spaces in filenames
    SPACE_FILES=$(echo "$STAGED_FILES" | grep " " || true)
    if [ ! -z "$SPACE_FILES" ]; then
        warning "Files with spaces in names:"
        echo "$SPACE_FILES" | sed 's/^/   - /'
    fi
    
    # Check for uppercase in directory names (except allowed ones)
    UPPERCASE_DIRS=$(echo "$STAGED_FILES" | grep -E "/[A-Z]" | grep -v -E "/(README|CLAUDE|KRINS|AI|MCP|DASHBOARD)" || true)
    if [ ! -z "$UPPERCASE_DIRS" ]; then
        warning "Directories with uppercase letters:"
        echo "$UPPERCASE_DIRS" | cut -d'/' -f1-2 | sort | uniq | sed 's/^/   - /'
    fi
}

# 6. RUN REPOSITORY HEALTH CHECK
run_health_check() {
    info "Running full repository health check..."
    
    if [ -x "$REPO_ROOT/tools/repository-health-checker.sh" ]; then
        if ! "$REPO_ROOT/tools/repository-health-checker.sh" > /dev/null 2>&1; then
            warning "Repository health check found issues"
            echo "Run: ./tools/repository-health-checker.sh for details"
        fi
    fi
}

# MAIN EXECUTION
main() {
    cd "$REPO_ROOT"
    
    check_root_files
    check_build_artifacts  
    check_secrets
    check_file_sizes
    check_naming
    run_health_check
    
    echo ""
    echo "======================================="
    
    if [ $ISSUES_FOUND -eq 0 ]; then
        success "üéâ COMMIT APPROVED - Repository protection passed!"
        echo -e "${GREEN}All checks passed. Your commit maintains repository health.${NC}"
        exit 0
    else
        echo -e "${RED}‚ùå COMMIT BLOCKED - $ISSUES_FOUND critical issues found${NC}"
        echo ""
        echo "üîß Fix the issues above and try again."
        echo "üí° Run './tools/repository-health-checker.sh' for detailed analysis."
        exit 1
    fi
}

main "$@"